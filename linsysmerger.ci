// *****************************************************************************
/*!
  \file      src/LinSys/linsysmerger.ci
  \author    J. Bakosi
  \date      Tue 10 May 2016 02:17:50 PM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system
*/
// *****************************************************************************

module linsysmerger {

  extern module conductor;

  namespace tk {

    // List all possible specializations of templated chare to instantiate
    // registration and delivery of code for the individual specializations

    // Will specialize linear system merger for Conductor & Performer
    chare LinSysMerger< inciter::CProxy_Conductor, inciter::CProxy_Performer >;

    // LinSysMerger is templated so that the same code (parameterized by the
    // type given by the template arguments, HostProxy and WorkerProxy) can be
    // generated for different types of proxies. Howver, all possible
    // specializations must be listed above to ensure that Charm++ generates
    // correct code.
    template< class HostProxy, class WorkerProxy >
    group LinSysMerger {
      entry LinSysMerger( const HostProxy& host,
                          const WorkerProxy& worker,
                          std::size_t ncomp );
      entry void bounds( int pe, std::size_t lower, std::size_t upper );
      entry void enable_wait4rhs();
      entry void addrow( int fromch,
                         int frompe,
                         const std::set< std::size_t >& row );
      entry void recrow();
      entry void addsol( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& sol );
      entry void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry void rowsreceived();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //
      // ChSol -- HypreSol -- FillSol -- AsmSol -
      //                                         \
      // ChLhs -- HypreLhs -- FillLhs -- AsmLhs -- Sol - Upd
      //                                         /
      // ChRhs -- HypreRhs -- FillRhs -- AsmRhs -
      //
      // DAG legend:
      //   ChSol - Chares contribute their solution vector nonzeros
      //   ChLhs - Chares contribute their left hand side matrix nonzeros
      //   ChRhs - Chares contribute their right hand side vector nonzeros
      //   HypreSol - Convert solution vector to Hypre format
      //   HypreLhs - Convert left hand side matrix to Hypre format
      //   HypreSol - Convert right hand side vector to Hypre format
      //   FillSol - Fill/set solution vector
      //   FillLhs - Fill/set left hand side matrix
      //   FillRhs - Fill/set right hand side vector
      //   AsmSol - Assemble solution vector
      //   AsmLhs - Assemble left hand side matrix
      //   AsmRhs - Assemble right hand side vector
      //   Sol - Solve linear system
      //   Upd - Update solution vector (propagate new solution back to workers)
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // We start out with all Performer (worker) chares contributing their
      // portion of the solution (unknown) vector, the nonzero values of the
      // left hand side matrix, and the right hand side vector to those Linear
      // System Merger group branch (one per CPU) they happened to reside on.
      // These steps are denoted by ChSol, ChLhs, and ChRhs in the graph above,
      // performed by the member functions charesol(), charelhs(), and
      // charerhs(), respectively.
      //
      // Once each of the tasks, ChSol, ChLhs, ChRhs, (not all at the same time
      // but separately) are done, we continue by converting these data
      // structures to a format that Hypre expects, done in hypresol(),
      // hyprelhs(), and hyprerhs(), denoted by similars labels in the graph.
      // These functions basically flatten the C++ data structures to C-style
      // arrays and linked arrays (for the matrix).
      //
      // Once the tasks, HypreSol, HypreLhs, HypreRhs, (not all at the same time
      // but separately) are done, we continue by assigning the flattened data
      // structures (more precisely, their pointers) to the Hypre vectors and
      // matrix. These are denoted FillSol, FillLhs, and FillRhs in the DAG and
      // correspond to the functions sol(), lhs(), and rhs().
      //
      // Once the tasks, FillSol, FillLhs, FIllRhs, (not all at the same time,
      // but separately) are, we continue by calling the Hypre "assembly"
      // routines for the solution vector, the left hand side matrix, and the
      // right hand side vector. These are denoted by AsmSol, AsmLhs, and AsmRhs
      // in the DAG, and performed by the member functions assemblesol(),
      // assemblelhs(), and assemblerhs(), respectively.
      //
      // Once the assembly of the solution (unknown) vector, the left hand side
      // matrix, and the right hand side vector are all done (on a CPU), we call
      // the solve() member function which solves the linear system calling
      // Hypre and also updates the solution, i.e., propagates the new solution
      // back to the worker (Performer) chares.
      //
      // Note that Sol and Upd are both partial synchronization points, since
      // they can happen at different times on different CPUs.

      entry void wait4sol()
      { when trigger_sol_complete() serial "hypresol" { hypresol(); } };
      entry void wait4lhs()
      { when trigger_lhs_complete() serial "hyprelhs" { hyprelhs(); } };
      entry void wait4rhs()
      { when trigger_rhs_complete() serial "hyprerhs" { hyprerhs(); } };

      entry void wait4hypresol()
      { when trigger_hypresol_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs()
      { when trigger_hyprelhs_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs()
      { when trigger_hyprerhs_complete() serial "rhs" { rhs(); } };

      entry void wait4fillsol()
      { when trigger_fillsol_complete() serial "asmsol" { assemblesol(); } };
      entry void wait4filllhs()
      { when trigger_filllhs_complete() serial "asmlhs" { assemblelhs(); } };
      entry void wait4fillrhs()
      { when trigger_fillrhs_complete() serial "asmrhs" { assemblerhs(); } };

      entry void wait4asm() {
        when trigger_asmsol_complete(),
             trigger_asmlhs_complete(),
             trigger_asmrhs_complete()
        serial "solve" { solve(); }
      };

      entry void trigger_lhs_complete();
      entry void trigger_rhs_complete();
      entry void trigger_sol_complete();
      entry void trigger_hyprelhs_complete();
      entry void trigger_hyprerhs_complete();
      entry void trigger_hypresol_complete();
      entry void trigger_filllhs_complete();
      entry void trigger_fillrhs_complete();
      entry void trigger_fillsol_complete();
      entry void trigger_asmlhs_complete();
      entry void trigger_asmrhs_complete();
      entry void trigger_asmsol_complete();
    };

  } // tk::

}
