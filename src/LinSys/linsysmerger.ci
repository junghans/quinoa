// *****************************************************************************
/*!
  \file      src/LinSys/linsysmerger.ci
  \author    J. Bakosi
  \date      Mon 24 Oct 2016 02:36:33 PM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system. See more
     in src/LinSys/LinSysMerger.h.
*/
// *****************************************************************************

module linsysmerger {

  include "unordered_map";

  extern module transporter;

  namespace tk {

    // List all possible specializations of templated chare to instantiate
    // registration and delivery of code for the individual specializations

    // Will specialize linear system merger for Transporter & Carrier
    chare LinSysMerger< inciter::CProxy_Transporter,
                        inciter::CProxy_Carrier,
                        inciter::AuxSolverLumpMassDiff >;

    // LinSysMerger is templated so that the same code (parameterized by the
    // type given by the template arguments, HostProxy and WorkerProxy) can be
    // generated for different types of proxies. Howver, all possible
    // specializations must be listed above to ensure that Charm++ generates
    // correct code.
    template< class HostProxy, class WorkerProxy, class AuxSolver >
    group LinSysMerger {
      entry LinSysMerger( const HostProxy& host,
                          const WorkerProxy& worker,
                          const std::map< int,
                            std::vector< std::size_t > >& side,
                          std::size_t ncomp );
      initnode void registerBCMerger();
      entry void bounds( int pe, std::size_t lower, std::size_t upper );
      entry void enable_wait4rhs();
      entry void addrow( int fromch,
                         int frompe,
                         const std::set< std::size_t >& row );
      entry void recrow();
      entry [reductiontarget] void addbc( CkReductionMsg* msg );
      entry void oldID( int fromch, const std::vector< std::size_t >& oldids );
      entry void charebcval( const std::unordered_map< std::size_t,
                            std::vector< std::pair< bool, tk::real > > >& bcv );
      entry [reductiontarget] void comlhsbc( CkReductionMsg* msg );
      entry void vercomplete();
      entry void addsol( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& solution );
      entry void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry void addauxrhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& auxrhs );
      entry void addauxlhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& auxlhs );
      entry void adddiag( int fromch,
                          const std::map< std::size_t,
                                          std::vector< tk::real > >& solution );

      entry void rowsreceived();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //
      // See src/LinSys/LinSysMerger.h.
      //
      // Interpretation of the DAG in src/LinSys/LinSysMerger.h
      // ------------------------------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // We start out with all worker chares contributing their porition of the
      // global row IDs that each work on. This is labelled ChRow. The worker
      // chares also contribute, in parallel, their portion of the global node
      // ID lists at which they can set boundary conditions, labelled, ChBCs.
      // Once both row IDs and BC node lists are received on LinSysMerger, we do
      // a global reduction to Transport::rowcomplete() spawns two broadcasts:
      // (1) to LinSysMerger::rowsreceived(), and (2) to worker::setup().
      //
      // The member function tk::LinSysMerger::rowsreceived(), labeled Ver in
      // the task-graph, triggers and performs a number tasks: (1) Verification
      // that ensures consistent global row IDs, labeled VerRow. This step only
      // happens in DEBUG mode: VerRow is simply an Assert in member function
      // rowsreceived). (2) Verification of the boundary contitions to be set
      // that they match those set by the user, labeled VerBCs. While this step
      // only happens in DEBUG mode, it involves multiple steps of communication
      // via multiple functions calls across three classes, LinSysMerger, host,
      // and worker. Note that this also involves multiple global reductions to
      // host originating from both the worker chares as well as from the
      // LinSysMerger group. Thus VerBCs is a global synchronization point and
      // thus colored and filled on the task-graph. The VerBCs code-path
      // culminates in tk::LinSysMerger::ver_complete(). Note both primary and
      // auxiliary solution updates, labeled Upd and AuxUpd, respectively,
      // depend on ver_complete(). While this is is not strictly necessary from
      // the correctness viewpoint, these dependencies are used to prevent the
      // runtime system prematurely scheduling other reductions that these
      // updates trigger in the worker chares, e.g., as a result of
      // inciter::Carrier::aec() and inciter::Carrier::alwd(). As to why it
      // is a problem to have multiple reductions in flight directed towards the
      // same host objects see the discussion at
      // https://lists.cs.illinois.edu/lists/arc/charm/2016-07/msg00033.html.
      // (3) The third task, tk::LinSysMerger::rowsreceived() initiates is
      // labeled QueryBCVal. This initiates querying boundary condition values
      // from worker chares. This step culminates is triggering the SDAG signals
      // bcval_complete(), which is a prerequisite for setting boundary
      // conditions on both left and right hand sides of both the auxiliary and
      // the primary linear systems. (4) The final step,
      // tk::LinSysMerger::rowsreceived() initiates is building Hypre data from
      // the global row indices received, labeled HypreRow.

      // Once the row IDs are contributed, tk::Transporter::rowcomplete(), not
      // only spaws tk::LinSysMerger::rowsreceived() but also issues a broadcast
      // to the worker chares to start initializing their system. This is
      // started with a call to the init() member function of the worker. The
      // tasks include setting initial conditions, sending unknown/solution
      // vectors for assembly to LinSysMerger, start computing the left and
      // right hand sides for both the primary and auxiliary systems, and
      // sending all this for linear system assembly. All worker chares
      // contribute their portion of the solution (unknown) vector, the nonzero
      // values of the left hand side matrix, their portion of the (diagonal)
      // auxiliary matrix, the right hand side vector for the primary system, as
      // well as for the auxiliary rhs term that is combined with the rhs of the
      // primary linear system to create the auxiliary system rhs.  The
      // contribution goes to those Linear System Merger group branch (one per
      // CPU) the workers happen to reside on. These steps are denoted by ChSol,
      // ChLhs, ChRhs, ChAuxLhs, and ChAuxRhs in the graph above, and the
      // contributions/assembly is performed by the member functions charesol(),
      // charelhs(), charerhs(), chareauxlhs(), and chareauxrhs(), respectively.
      //
      // Primary solution only: Once each of the tasks, ChSol, ChLhs, ChRhs,
      // (not all at the same time but separately) are done, we continue by
      // converting these data structures to a format that Hypre expects, done
      // in hypresol(), hyprelhs(), and hyprerhs(), denoted by similars labels
      // in the graph. These functions basically flatten the C++ data
      // structures to C-style arrays and linked arrays (for the matrix). Note
      // that the left and right hand sides can only begin to be converted to
      // Hypre data format if the boundary conditions have also been applied on
      // each. These are labeled LhsBC, RhsBC, and LumpBC and computed after
      // QueryBCVal has finished.
      //
      // Primary solution only: Once the tasks, HypreSol, HypreLhs, HypreRhs,
      // (not all at the same time but separately) are done and the Hypre data
      // structure for the row IDs are complete, we continue by assigning the
      // flattened data structures (more precisely, their pointers) to the Hypre
      // vectors and Hypre matrix.  These are denoted FillSol, FillLhs, and
      // FillRhs in the DAG and correspond to the member functions sol(), lhs(),
      // and rhs().
      //
      // Primary solution only: Once the tasks, FillSol, FillLhs, FIllRhs, (not
      // all at the same time, but separately) are, we continue by calling the
      // Hypre "assembly" routines for the solution vector, the left hand side
      // matrix, and the right hand side vector. These are denoted by AsmSol,
      // AsmLhs, and AsmRhs in the DAG, and performed by the member functions
      // assemblesol(), assemblelhs(), and assemblerhs(), respectively.
      //
      // Primary solution only: Once the assembly of the solution (unknown)
      // vector, the left hand side matrix, and the right hand side vector are
      // all done (on a CPU), labels AsmSol, AsmLhs, AsmRhs, respectively, we
      // call the solve() member function which solves the primary linear system
      // by calling Hypre and also updates the primary solution, i.e.,
      // propagates the new solution back to the worker chares, labeled Upd.
      //
      // Auxiliary solution only: The auxiliary solution is performed once the
      // primary right hand side vector, the auxiliary rhs vector (combined with
      // primary the rhs), and the auxiliary lhs are all complete. The solution
      // of the auxiliary system is a simple back-substitution, since the system
      // is assumed diagonal.
      //
      // Note that propagating the new primary and auxiliary solutions only
      // happen if not only the solutions are finished, but alse when the
      // optional verification step is completed. As discussed above this is
      // required so that we do not end up with multiple reductions in flight at
      // the same time.  If these were not in place, the strict ordering of each
      // CPU contributing to multiple reductions could not be guaranteed. See
      // also the discussion on the charm email list linked above.
      //
      // A word on multiple invokation of SDAG triggers: As the commit message
      // of b79ea29 explains, the "triggers", such as hyprerow_complete(),
      // enumerated below, at threir call site should be thought of as messages
      // being put in some message queue and consumed at when clauses wherever
      // they appear. If they appear in multiple when clauses, they consume
      // multple messages, thus they have to be triggered multiple times. See
      // also
      // https://lists.cs.illinois.edu/lists/arc/charm/2016-09/msg00002.html.
      //
      // As discussed in src/LinSys/LinSysMerger.h, the SDAG logic discussed
      // here is the same regardless whether an auxiliary linear solution is
      // performed.

      entry void wait4row() {
        when row_complete(), bc_complete() serial "row" {
          signal2host_row_complete( m_host ); } };

      entry void wait4lhsbc() {
        when lhs_complete(), bcval_complete() serial "lhsbc" { lhsbc(); } };
      entry void wait4rhsbc() {
        when rhs_complete(), bcval_complete() serial "rhsbc" { rhsbc(); } };
      entry void wait4auxbc() {
        when auxlhs_complete(), bcval_complete() serial "auxbc" { auxbc(); } };

      entry void wait4sol() {
        when sol_complete() serial "hypresol" { hypresol(); } };
      entry void wait4lhs() {
        when lhsbc_complete() serial "hyprelhs" { hyprelhs(); } };
      entry void wait4rhs() {
        when rhsbc_complete() serial "hyprerhs" { hyprerhs(); } };

      entry void wait4hypresol() {
        when hypresol_complete(), hyprerow_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs() {
        when hyprelhs_complete(), hyprerow_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs() {
        when hyprerhs_complete(), hyprerow_complete() serial "rhs" { rhs(); } };

      entry void wait4fillsol() {
        when fillsol_complete() serial "asmsol" { assemblesol(); } };
      entry void wait4filllhs() {
        when filllhs_complete() serial "asmlhs" { assemblelhs(); } };
      entry void wait4fillrhs() {
        when fillrhs_complete() serial "asmrhs" { assemblerhs(); } };

      entry void wait4asm() {
        when asmsol_complete(), asmlhs_complete(), asmrhs_complete()
          serial "solve" { solve(); } };
      entry void wait4aux() {
        when rhs_complete(), auxrhs_complete(), auxbc_complete()
          serial "aux" { auxsolve(); } };

      entry void wait4solve() {
        when solve_complete(), ver_complete() serial "update" {
          updateSol(); } };
      entry void wait4auxsolve() {
        when auxsolve_complete(), ver_complete() serial "updateaux" {
          updateAuxSol(); } };

      entry void row_complete();
      entry void bc_complete();
      entry void bcval_complete();
      entry void lhsbc_complete();
      entry void rhsbc_complete();
      entry void auxbc_complete();
      entry void ver_complete();
      entry void hyprerow_complete();
      entry void lhs_complete();
      entry void rhs_complete();
      entry void sol_complete();
      entry void auxrhs_complete();
      entry void auxlhs_complete();
      entry void hyprelhs_complete();
      entry void hyprerhs_complete();
      entry void hypresol_complete();
      entry void filllhs_complete();
      entry void fillrhs_complete();
      entry void fillsol_complete();
      entry void asmlhs_complete();
      entry void asmrhs_complete();
      entry void asmsol_complete();
      entry void solve_complete();
      entry void auxsolve_complete();
    };

  } // tk::

}
