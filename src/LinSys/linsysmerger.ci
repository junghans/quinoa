// *****************************************************************************
/*!
  \file      src/LinSys/linsysmerger.ci
  \author    J. Bakosi
  \date      Fri 02 Sep 2016 03:23:29 PM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system
*/
// *****************************************************************************

module linsysmerger {

  include "unordered_map";

  extern module transporter;

  namespace tk {

    // List all possible specializations of templated chare to instantiate
    // registration and delivery of code for the individual specializations

    // Will specialize linear system merger for Transporter & Carrier
    chare LinSysMerger< inciter::CProxy_Transporter,
                        inciter::CProxy_Carrier >;

    // LinSysMerger is templated so that the same code (parameterized by the
    // type given by the template arguments, HostProxy and WorkerProxy) can be
    // generated for different types of proxies. Howver, all possible
    // specializations must be listed above to ensure that Charm++ generates
    // correct code.
    template< class HostProxy, class WorkerProxy >
    group LinSysMerger {
      entry LinSysMerger( const HostProxy& host,
                          const WorkerProxy& worker,
                          const std::map< int,
                            std::vector< std::size_t > >& side,
                          std::size_t ncomp );
      initnode void registerBCMerger();
      entry void bounds( int pe, std::size_t lower, std::size_t upper );
      entry void enable_wait4rhs();
      entry void addrow( int fromch,
                         int frompe,
                         const std::set< std::size_t >& row );
      entry void recrow();
      entry [reductiontarget] void addbc( CkReductionMsg* msg );
      entry void oldID( int fromch, const std::vector< std::size_t >& oldids );
      entry void charebcval( const std::unordered_map< std::size_t,
                            std::vector< std::pair< bool, tk::real > > >& bcv );
      entry [reductiontarget] void bcval( CkReductionMsg* msg );
      entry void addsol( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& sol );
      entry void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry void adddiff( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& diff );
      entry void addlump( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& mass );
      entry void rowsreceived();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //
      //                  -- ChSol -- HypreSol -- FillSol -- AsmSol --
      //                 /                      /                     \
      //   ChRow --- Ver --- ChLhs -- HypreLhs -- FillLhs -- AsmLhs -- Sol - Upd
      //             /| \            /          |   /                  /
      //            / |  \          |           |---                  /
      //           /  |   \         |           |                    /
      //   ChBCs --   |    - ChRhs -- HypreRhs -- FillRhs -- AsmRhs -
      //              |             |/          /     /
      //              |-- HypreRow ------------------
      //              |             |
      //              |-- VerRow    |
      //              \            /
      //               -- VerBCs --
      //
      // DAG legend:
      //   ChRow - Chares contribute their global row (mesh node) IDs
      //   ChBCs - Chares offer their global node IDs at which they can set BCs
      //   ChSol - Chares contribute their solution vector nonzeros
      //   ChLhs - Chares contribute their left hand side matrix nonzeros
      //   ChRhs - Chares contribute their right hand side vector nonzeros
      //   Ver - Start optional verifications and HypreRow (see below)
      //   VerRow - Optional verification ensuring consistent row IDs
      //   VerBCs - Optional verification ensuring consistent BC node IDs
      //   HypreRow - Convert global row ID vector to Hypre format
      //   HypreSol - Convert solution vector to Hypre format
      //   HypreLhs - Convert left hand side matrix to Hypre format
      //   HypreSol - Convert right hand side vector to Hypre format
      //   FillSol - Fill/set solution vector
      //   FillLhs - Fill/set left hand side matrix
      //   FillRhs - Fill/set right hand side vector
      //   AsmSol - Assemble solution vector
      //   AsmLhs - Assemble left hand side matrix
      //   AsmRhs - Assemble right hand side vector
      //   Sol - Solve linear system
      //   Upd - Update solution vector (propagate new solution back to workers)
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // We start out with all worker chares contributing their porition of the
      // global row IDs that each work on. This is labelled ChRow. The worker
      // chares also contribute, in parallel, their portion of the global node
      // ID lists at which they can set boundary conditions, labelled, ChBCs.
      // Once both row IDs and BC node lists are received on LinSysMerger, the
      // row IDs start being converted to a flat data structure understood by
      // hypre, labelled HypreRow.
      //
      // The Ver partial synchronization point, besides HypreRow, also triggers
      // two code paths verifying the received BCs as well as the row IDs. Both
      // of these verification code paths only happen in DEBUG mode and skipped
      // in RELEASE (optimized) mode. While VerRow is simply an Assert in
      // rowsreceived(), VerBCs involves multiple steps of communication via
      // multiple functions calls across three classes, LinSysMerger, host, and
      // worker. While the VerBCs optional code path only happens in DEBUG mode,
      // the code path does block on HypreLhs as well as on HypreRhs, which
      // cannot proceed until VerBCs is finished. This is facilitated by
      // 'ver_complete' which is true by default, set in the constructor only in
      // RELEASE mode; in DEBUG mode it must be triggered by host::doverifybc(),
      // which is the last step of verifying the BCs.
      //
      // Once the row IDs are contributed, we then continue by all worker chares
      // contributing their portion of the solution (unknown) vector, the
      // nonzero values of the left hand side matrix, and the right hand side
      // vector to those Linear System Merger group branch (one per CPU) they
      // happened to reside on. These steps are denoted by ChSol, ChLhs, and
      // ChRhs in the graph above, performed by the member functions charesol(),
      // charelhs(), and charerhs(), respectively.
      //
      // Once each of the tasks, ChSol, ChLhs, ChRhs, (not all at the same time
      // but separately) are done, we continue by converting these data
      // structures to a format that Hypre expects, done in hypresol(),
      // hyprelhs(), and hyprerhs(), denoted by similars labels in the graph.
      // These functions basically flatten the C++ data structures to C-style
      // arrays and linked arrays (for the matrix).
      //
      // Once the tasks, HypreSol, HypreLhs, HypreRhs, (not all at the same time
      // but separately) are done and the hypre data structure for the row IDs
      // are complete, we continue by assigning the flattened data structures
      // (more precisely, their pointers) to the Hypre vectors and matrix. These
      // are denoted FillSol, FillLhs, and FillRhs in the DAG and correspond to
      // the functions sol(), lhs(), and rhs().
      //
      // Once the tasks, FillSol, FillLhs, FIllRhs, (not all at the same time,
      // but separately) are, we continue by calling the Hypre "assembly"
      // routines for the solution vector, the left hand side matrix, and the
      // right hand side vector. These are denoted by AsmSol, AsmLhs, and AsmRhs
      // in the DAG, and performed by the member functions assemblesol(),
      // assemblelhs(), and assemblerhs(), respectively.
      //
      // Once the assembly of the solution (unknown) vector, the left hand side
      // matrix, and the right hand side vector are all done (on a CPU), we call
      // the solve() member function which solves the linear system calling
      // Hypre and also updates the solution, i.e., propagates the new solution
      // back to the worker chares.
      //
      // Note that Sol and Upd are both partial synchronization points, since
      // they can happen at different times on different CPUs.

      entry void wait4row() {
        when row_complete(), bc_complete() serial "row" {
          signal2host_row_complete( m_host ); } };

      entry void wait4lhsbc() {
        when lhs_complete(), bcval_complete() serial "lhsbc" { lhsbc(); } };
      entry void wait4rhsbc() {
        when rhs_complete(), bcval_complete() serial "rhsbc" { rhsbc(); } };

      entry void wait4sol() {
        when sol_complete() serial "hypresol" { hypresol(); } };
      entry void wait4lhs() {
        when lhs_complete(), lhsbc_complete(), ver_complete() serial "hyprelhs"{
          hyprelhs(); } };
      entry void wait4rhs() {
        when rhs_complete(), rhsbc_complete(), ver_complete() serial "hyprerhs"{
          hyprerhs(); } };
      entry void wait4loworder() {
        when rhs_complete(), sol_complete(), diff_complete(), lump_complete()
        serial "lowsolve" { lowsolve(); } };

      entry void wait4hypresol() {
        when hypresol_complete(), hyprerow_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs() {
        when hyprelhs_complete(), hyprerow_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs() {
        when hyprerhs_complete(), hyprerow_complete() serial "rhs" { rhs(); } };

      entry void wait4fillsol() {
        when fillsol_complete() serial "asmsol" { assemblesol(); } };
      entry void wait4filllhs() {
        when filllhs_complete() serial "asmlhs" { assemblelhs(); } };
      entry void wait4fillrhs() {
        when fillrhs_complete() serial "asmrhs" { assemblerhs(); } };

      entry void wait4asm() {
        when asmsol_complete(), asmlhs_complete(), asmrhs_complete(),
             lowsolve_complete()
        serial "solve" { solve(); } };

      entry void row_complete();
      entry void bc_complete();
      entry void bcval_complete();
      entry void lhsbc_complete();
      entry void rhsbc_complete();
      entry void ver_complete();
      entry void hyprerow_complete();
      entry void lhs_complete();
      entry void rhs_complete();
      entry void sol_complete();
      entry void diff_complete();
      entry void lump_complete();
      entry void hyprelhs_complete();
      entry void hyprerhs_complete();
      entry void hypresol_complete();
      entry void filllhs_complete();
      entry void fillrhs_complete();
      entry void fillsol_complete();
      entry void asmlhs_complete();
      entry void asmrhs_complete();
      entry void asmsol_complete();
      entry void lowsolve_complete();
    };

  } // tk::

}
