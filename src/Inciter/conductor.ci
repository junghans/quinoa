// *****************************************************************************
/*!
  \file      src/Inciter/conductor.ci
  \author    J. Bakosi
  \date      Tue 02 Aug 2016 08:11:38 AM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for Conductor
  \details   Charm++ module interface file for Conductor
*/
// *****************************************************************************

module conductor {

  extern module partitioner;

  namespace inciter {

    chare Conductor {
      entry Conductor();
      entry [reductiontarget] void load( uint64_t nelem );
      entry [reductiontarget] void partition();
      entry [reductiontarget] void flattened();
      entry [reductiontarget] void setup();
      entry [reductiontarget] void aveCost( tk::real c );
      entry [reductiontarget] void stdCost( tk::real c );
      entry [reductiontarget] void rowcomplete();
      entry [reductiontarget] void nparcomplete();
      entry [reductiontarget] void verifybc( CkReductionMsg* msg );
      entry [reductiontarget] void doverifybc( CkReductionMsg* msg );
      entry [reductiontarget] void initcomplete();
      entry [reductiontarget] void diagnostics( tk::real d[n], std::size_t n );
      entry [reductiontarget] void diagcomplete();
      entry [reductiontarget] void parcomplete();
      entry [reductiontarget] void evaluateTime();
      entry [reductiontarget] void advance();
      entry [reductiontarget] void finish();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //                                    DAG legend:
      //  Row  -- Init                        Row  - linear system rows complete
      //         /                            Npar - number of particles sent
      //  Npar --                             Init - initialization continues
      //
      //  Diag -- Rep                         Diag - compute diagnostics
      //         /                            Eval - evalaute time step
      //  Eval --                             Rep  - output one-liner report
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // Only if both all linear system merger branches have done their part of
      // storing and exporting global row ids (Row) and the number of particles
      // workers will contribute to outputing to file (Npar), the initialization
      // can continue (Init).
      //
      // Outputing a one-liner report (Rep) can only be done if both the
      // diagnostics have been collected (Diag) as well as the time step has
      // been evaluated (Eval). The report is only output at the final time step
      // stage. Collecting diagnostics if optional, i.e., it does not happen
      // every time step. If diagnostics are collected trigger_diag_complete()
      // is signaled from the reduction target, Conductor::diagnostics(). If
      // diagnostics are not collected in a time step, collection is skipped,
      // and trigger_diag_complete() is signaled from the shortcut function,
      // Conductor::diagcomplete(). Either way, the above DAG and its logic
      // remains the same.

      entry void wait4init()
      { when trigger_row_complete(), trigger_npar_complete() serial "init"
        { m_performer.init( m_dt ); } };

      entry void wait4report()
      { when trigger_eval_complete(),
             trigger_par_complete(),
             trigger_diag_complete() serial "report"
        { report(); } };

      entry void trigger_row_complete();
      entry void trigger_npar_complete();
      entry void trigger_eval_complete();
      entry void trigger_par_complete();
      entry void trigger_diag_complete();
    }

  } // inciter::

}
