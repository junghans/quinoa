// *****************************************************************************
/*!
  \file      src/Inciter/conductor.ci
  \author    J. Bakosi
  \date      Tue 02 Aug 2016 08:11:38 AM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for Conductor
  \details   Charm++ module interface file for Conductor
*/
// *****************************************************************************

module conductor {

  extern module partitioner;

  namespace inciter {

    chare Conductor {
      entry Conductor();
      entry [reductiontarget] void load( uint64_t nelem );
      entry [reductiontarget] void partition();
      entry [reductiontarget] void flattened();
      entry [reductiontarget] void setup();
      entry [reductiontarget] void aveCost( tk::real c );
      entry [reductiontarget] void stdCost( tk::real c );
      entry [reductiontarget] void rowcomplete();
      entry [reductiontarget] void nparcomplete();
      entry [reductiontarget] void msumcomplete();
      entry [reductiontarget] void verifybc( CkReductionMsg* msg );
      entry [reductiontarget] void doverifybc( CkReductionMsg* msg );
      entry [reductiontarget] void initcomplete();
      entry [reductiontarget] void diagnostics( tk::real d[n], std::size_t n );
      entry [reductiontarget] void diagcomplete();
      entry [reductiontarget] void parcomplete();
      entry [reductiontarget] void evaluateTime();
      entry [reductiontarget] void advance();
      entry [reductiontarget] void finish();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //                                    DAG legend:
      //  Row  -- Init                        Row  - linear system rows complete
      //         /  |                         Npar - number of particles sent
      //  Npar --   |                         Msum - mesh surrounding mesh
      //           /                          Init - initialization continues
      //  Msum ---
      //
      //  Diag -- Rep                         Diag - compute diagnostics
      //         / |                          Eval - evalaute time step
      //  Eval --  |                          Par  - particle output to file
      //           /                          Rep  - output one-liner report
      //  Par ----
      //
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // Only if both all of (1) linear system merger branches have done their
      // part of storing and exporting global row ids (Row), (2) the number of
      // particles workers will contribute to have been received by the particle
      // writers (Npar), and (3) the mesh chunks surrounding mesh chunks data
      // structure has been built (Msum), the initialization can continue
      // (Init). Note that Npar and Msum are optional, and only required (and
      // triggered) if there are particles to advance (given by user input).
      //
      // Outputing a one-liner report (Rep) can only be done if all of (1) the
      // diagnostics have been collected (Diag), (2) the time step has been
      // evaluated (Eval), and (3) particles have been output. The report is
      // only output at the final time step stage. Collecting diagnostics is
      // optional, i.e., it does not happen every time step. If diagnostics are
      // collected trigger_diag_complete() is signaled from the reduction
      // target, Conductor::diagnostics(). If diagnostics are not collected in a
      // time step, collection is skipped, and trigger_diag_complete() is
      // signaled from the shortcut function, Conductor::diagcomplete(). Similar
      // to diagnostics output, particle output is also optional and does not
      // happen every time step. The Charm++ reduction target
      // Conductor::parcomplete() is reached either way but on different routes:
      // if particles are output the reduction originates from the
      // ParticleWriter Charm++ group after writeCoords() finished the output,
      // if particles are not output, the reduction originates from
      // Performer::updateSolution(). Either way, the above DAG and its logic
      // remains the same.

      entry void wait4init()
      { when trigger_row_complete(),
             trigger_npar_complete(),
             trigger_msum_complete() serial "init"
        { m_performer.init( m_dt ); } };

      entry void wait4report()
      { when trigger_eval_complete(),
             trigger_par_complete(),
             trigger_diag_complete() serial "report"
        { report(); } };

      entry void trigger_row_complete();
      entry void trigger_npar_complete();
      entry void trigger_msum_complete();
      entry void trigger_eval_complete();
      entry void trigger_par_complete();
      entry void trigger_diag_complete();
    }

  } // inciter::

}
