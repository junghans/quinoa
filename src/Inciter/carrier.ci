// *****************************************************************************
/*!
  \file      src/Inciter/carrier.ci
  \author    J. Bakosi
  \date      Fri 09 Sep 2016 02:29:01 PM MDT
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for Carrier
  \details   Charm++ module interface file for Carrier
*/
// *****************************************************************************

module carrier {

  extern module transporter;
  extern module linsysmerger;
  extern module particlewriter;

  include "Particles.h";

  namespace inciter {

    array [1D] Carrier {
      entry
        Carrier( const CProxy_Transporter& transporter,
                 const tk::CProxy_LinSysMerger< CProxy_Transporter,
                                                CProxy_Carrier >& lsm,
                 const tk::CProxy_ParticleWriter< CProxy_Transporter >& pw,
                 const std::vector< std::size_t >& conn,
                 const std::unordered_map< std::size_t, std::size_t >& cid,
                 int ncarr );
      initnode void registerReducers();
      entry void comm();
      entry [reductiontarget] void msum( CkReductionMsg* msg );
      entry void setup();
      entry void requestBCs();
      entry void oldID( int frompe, const std::vector< std::size_t >& newids );
      entry void bcval( int frompe, const std::vector< std::size_t >& nodes );
      entry void init( tk::real dt );
      entry void updateHighSol( const std::vector< std::size_t >& gid,
                                const std::vector< tk::real >& sol );
      entry void updateLowSol( const std::vector< std::size_t >& gid,
                               const std::vector< tk::real >& sol );
      entry void advance( uint8_t stage, tk::real dt, uint64_t it, tk::real t );
      entry void findpar( int fromch,
                          const std::vector< std::size_t >& miss,
                          const tk::Particles& ps );
      entry void foundpar( const std::vector< std::size_t >& found );
      entry void collectpar( int fromch,
                             const std::vector< std::size_t >& miss,
                             const tk::Particles& ps );
      entry void collectedpar( const std::vector< std::size_t >& found );
      entry void out();
      entry void doWriteParticles();
      entry void finishaec( int fromch,
                            const std::vector< std::size_t >& gid,
                            const std::vector< std::vector< tk::real > >& P );
      entry void recaec();
      entry
        void finishallowed( int fromch,
                            const std::vector< std::size_t >& gid,
                            const std::vector< std::vector< tk::real > >& Q );
      entry void recallowed();
      entry void limit();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //                                   DAG legend:
      //  AEC  --  Limit                    AEC - communication of
      //           /                          antidiffusive element
      //  Allowed -                           contributions complete
      //                                    Allowed - communication of
      //                                      allowed solution increments
      //                                      and decrements complete
      //
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // Only if both the communication of antidiffusive element contributions
      // (AEC) and the communication of the allowed solution increments and
      // decrements (Allowed) have been completed, can Limit be performed.

      entry void wait4fct() {
        when aec_complete(), alw_complete() serial "fct" {
          contribute( CkCallback( CkReductionTarget( Transporter, limit ),
                                  m_transporter ) );
        } };

      entry void aec_complete();
      entry void alw_complete();
    };

  } // inciter::

}
